#### 一个普通java程序包含的线程

```java
package com.company.jmxthread;

import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;

public class Main {
    public static void main(String[] args) {
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
        for (ThreadInfo threadInfo : threadInfos) {
            System.out.println(threadInfo.getThreadId() + "   " + threadInfo.getThreadName());
        }
    }
}
```



输出：

```
5   Monitor Ctrl-Break //只有在idea里面运行才会被打印出来
4   Signal Dispatcher //分发处理发送给JVM信号的线程
3   Finalizer //调用对象finalize方法的线程
2   Reference Handler //清除Reference的线程
1   main //main线程，用户程序的入口
```



#### 线程优先级

java线程中可以通过一个整形的成员变量priority来控制优先级，优先级的范围是1~10。可以通过setPriority(int)方法来修改优先级。

不同的JVM以及操作系统上，有些会忽略线程的优先级设定。

```java
package com.company.threadpriority;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class Main {
    private static volatile boolean notStart = true;
    private static volatile boolean notEnd = true;

    public static void main(String[] args) throws InterruptedException {
        List<Job> jobs = new ArrayList<Job>();
        for (int i = 0; i < 10; i++) {
            int priority = i < 5 ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;
            Job job = new Job(priority);
            jobs.add(job);
            Thread thread = new Thread(job, "Thread" + i);
            thread.setPriority(priority);
            thread.start();
        }
        notStart = false;
        TimeUnit.SECONDS.sleep(10);
        notEnd = false;
        for (Job job : jobs) {
            System.out.println("Job Priority " + job.priority + " ,Count " + job.jobCount);
        }
    }

    static class Job implements Runnable {
        private int priority;
        private long jobCount;

        public Job(int priority) {
            this.priority = priority;
        }

        @Override
        public void run() {
            while (notStart) {
                Thread.yield();
            }
            while (notEnd) {
                Thread.yield();
                jobCount++;
            }
        }
    }
}
```



输出：

```
Job Priority 1 ,Count 603897
Job Priority 1 ,Count 604361
Job Priority 1 ,Count 604077
Job Priority 1 ,Count 604284
Job Priority 1 ,Count 604120
Job Priority 10 ,Count 604259
Job Priority 10 ,Count 604512
Job Priority 10 ,Count 604021
Job Priority 10 ,Count 604503
Job Priority 10 ,Count 604707
```

通过jstack查看，忽略了我们设置的优先级

mac os 

Jdk 1.8

```
"Thread1" #11 prio=1 os_prio=31 tid=0x00007fa77009b800 nid=0x4003 runnable [0x0000700010f6a000]
   java.lang.Thread.State: RUNNABLE
        at java.lang.Thread.yield(Native Method)
        at com.company.threadpriority.Main$Job.run(Main.java:43)
        at java.lang.Thread.run(Thread.java:748)


"Thread7" #17 prio=10 os_prio=31 tid=0x00007fa76f84f800 nid=0xa303 runnable [0x000070001157c000]
   java.lang.Thread.State: RUNNABLE
        at java.lang.Thread.yield(Native Method)
        at com.company.threadpriority.Main$Job.run(Main.java:43)
        at java.lang.Thread.run(Thread.java:748)
```



#### 线程的状态

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被创建 还没被调用start方法                     |
| RUNNABLE     | 运行状态，Java线程将操作系统中的就绪和运行都笼统的成为“运行中” |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，表示线程进入等待状态，表示当前线程需要等待其它线程做出一些特定动作（通知或中断） |
| TIME_WAITING | 超时等待状态，可以在指定时间内自行返回                       |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |

```java
public class Main {
    public static void main(String[] args) {
        new Thread(new TimeWaiting(), "TimeWaitingThread").start();

        new Thread(new Waiting(), "WaitingThread").start();

        new Thread(new Blocked(), "BlockedThread-1").start();

        new Thread(new Blocked(), "BlockedThread-2").start();
    }

    static class TimeWaiting implements Runnable{

        @Override
        public void run() {
            while(true) {
                SleepUtils.second(100);
            }
        }
    }

    static class Waiting implements Runnable {
        @Override
        public void run() {
            while (true) {
                synchronized (Waiting.class) {
                    try {
                        Waiting.class.wait();
                    }catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static class Blocked implements Runnable {
        @Override
        public void run() {
            synchronized (Blocked.class) {
                while(true) {
                    SleepUtils.second(100);
                }
            }
        }
    }
}


public class SleepUtils {
    public static final void second(long seconds) {
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {

        }
    }
}
```

可以通过jps看到线程的状态

进入等待状态的线程需要依靠其它线程的通知才能返回到运行状态，调用wait方法可以进入等待状态

超时当代状态的=等待状态的基础上增加了超时，超时时间到达时会变成运行状态

线程没有获取到锁会进入阻塞状态

调用完run后会进入终止状态



#### Daemon线程

调用Thread.setDaemon(true)可以让线程运行在后台，就是守护线程的的意思

JVM里没有Daemon线程的时候，JVM会退出

Daemon属性需要在线程启动前设置

在JVM退出时，Daemon线程里的final块可能不会被执行



